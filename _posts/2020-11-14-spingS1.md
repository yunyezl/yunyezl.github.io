---
title:  "[Spring] Session 1. 객체 지향 설계와 스프링"
excerpt: "인프런 - 스프링 핵심 원리 기본편"

categories:
  - Spring
tags:
  - java
  - spring
  - solid
last_modified_at: 2020-11-14T12:42:00-05:00
---

# 섹션 1.  객체 지향 설계와 스프링
## 역할과 구현의 분리
* 역할과 구현으로 구분하면 세상이 단순해지고, 유연해지며 변경도 편리해진다.
* 장점
	* 클라이언트는 대상의 역할(인터페이스)만 알면 된다.
	* 클라이언트는 구현 대상의 내부 구조를 몰라도 된다.
	* 클라이언트는 구현 대상의 내부 구조가 변경되어도 영향을 받지 않는다.
	* 클라이언트는 구현 대상 자체를 변경해도 영향을 받지 않는다.
	
## 역할과 구현의 분리 - JAVA
* 자바 언어의 다형성 활용
	* 역할 = 인터페이스
	* 구현 = 인터페이스를 구현한 클래스, 구현 객체
* 객체 설계시 역할을 먼저 부여하고, 그 역할을 수행하는 구현 객체 만들기

## 좋은 객체 지향 설계의 5가지 원칙 (SOLID)
### 1. SRP 단일 책임 원칙 Single responsibility principle
* 한 클래스는 하나의 책임만 가져야 한다.
* 변경이 있을 때 파급 효과가 적을수록 단일 책임 원칙을 잘 따른 것.
### 2. OCP 개방-폐쇄 원칙 Open/closed principle
* 다형성을 활용하여 소프트웨어 요소를 확장에는 열려 있으나 변경에는 닫혀 있도록 구현해야 함
* 인터페이스를 구현한 새로운 클래스를 하나 만들어서 새로운 기능을 구현
* 객체를 생성할 때 클라이언트가 구현 클래스를 직접 선택하는 방식
~~~Java
// MemberRepository m = new MemoryMemberRepository(); 
MemberRepository m = new JdbcMemberRepository(); 
~~~
-> 구현 객체를 변경하려면 클라이언트 코드를 변경해야 함. (OCP 원칙 위반)
* 객체를 생성하고, 연관 관계를 맺어주는 별도의 조립, 설정자를 통해 이 같은 문제를 해결
### 3. LSP 리스코프 치환 원칙 Liskov substitution principle
* 프로그램의 객체는 프로그램의 정확성을 깨뜨리지 않으면서 하위 타입의 인스턴스로 바꿀 수 있어야 함
* 예) 자동차 인터페이스의 엑셀은 앞으로 가는 기능임. 뒤로 가도록 구현하면 LSP 위반.
* 뒤로 가도록 구현하더라도 컴파일 에러는 나지 않음. 따라서 이는 단순히 컴파일에 성공하는 것을 넘어서는 이야기임.
### 4. ISP 인터페이스 분리 원칙 Interface segregation principle
* 특정 클라이언트를 위한 인터페이스 여러 개가 범용 인터페이스 하나보다 낫다.
* 자동차 인터페이스 -> 운전 인터페이스, 정비 인터페이스로 분리
* 사용자 클라이언트 -> 운전자 클라이언트, 정비사 클라이언트로 분리
* 분리하면 정비 인터페이스가 변해도 운전자 클라이언트에 영향을 미치지 않음
### 5. DIP 의존관계 역전 원칙 Dependency inversion principle
* 프로그래는 “추상화에 의존해야지, 구체화에 의존해서는 안된다.”
* 클라이언트가 인터페이스에 의존하지 않고 구현 객체에 의존하게 되면 변경이 어려워짐.
* 연극에서 어떠한 역할을 맡은 “배우”에 의존하는 것이 아니라  “역할” 그 자체에 의존해야함. (배우가 변경되더라도 영향이 없어야함!)
~~~Java
// MemberRepository m = new MemoryMemberRepository(); 
MemberRepository m = new JdbcMemberRepository(); 
~~~
-> 앞서 OCP에서 나온 이 코드는 DIP 또한 위반한다. MemberService 클라이언트가 구현 클래스를 직접 선택하고 있기 때문이다.  
-> 결국, 다형성만으로는 OCP와 DIP를 지킬 수 없음.

## 스프링을 통해 이 같은 문제를 해결할 수 있다
* 스프링은 다음 기술로 다형성 + OCP, DIP를 가능하게 지원
	* DI(Dependency Injection): 의존관계, 의존성 주입
	* DI 컨테이너 제공
* 클라이언트 코드의 변경 없이 기능 확장이 가능하게 됨

-------------

> 본 강의를 듣게 되면서 내가 지금까지 짰던 코드들이 생각나면서 발가벗겨지는(?) 기분이었다. 이론으로는 객체 지향이 무엇인지, 다형성이 무엇인지 열심히 공부했지만 정작 구현을 할 때는 이러한 원칙들을 전혀 고려하지 않고 코드를 작성하고 있었다.  여태까지 프로젝트를 할 때마다 변경이 일어날 때마다 한숨부터 나왔던 것이 바로 이러한 원칙들을 지키지 않았기 때문에 일어난 것이였음을.. 🥺 프로젝트를 할 때 무작정 코드부터 작성하는 것이 아닌 코드를 “설계”하는 것의 중요성을 깨닫게 되었다. 섹션 3까지 듣고 해당 문서를 작성하고 있다.  스프링이 완전히 처음이라 모든 내용을 완전히 소화하고 있진 못하지만 복습할 때마다 더 와닿는 느낌이다. 더 열심히 들어야겠다.  
