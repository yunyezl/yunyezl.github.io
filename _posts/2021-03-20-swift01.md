---
title:  "[Swift] 구조체와 클래스"
excerpt: "swfit 문법 공부"

categories:
  - swift
tags:
  - swift
last_modified_at: 2021-03-19T05:48:00-05:00
---
### 구조체
~~~
struct 구조체 이름 {
	프로퍼티와 메서드들
}
~~~
* 사람의 기본 정보를 구성하는 구조체 정의
~~~swift
struct BasicInformation {
	var name: String
	var age: Int
}
~~~

* 구조체의 인스턴스 생성 및 초기화  
-> 구조체 정의를 마친 후, 인스턴스를 생성하고 초기화하고자 할 때는 기본적으로 생성되는 멤버 와이즈 이니셜라이저를 사용. 인스턴스가 생성되고 초기화 된 후 마침표를 통해 프로퍼티 값에 접근할 수 있다.

~~~swift
var yejiInfo: BasicInformation = BasicInformation(name: "yagom", age: 99)
yejiInfo.age = 25					// 변경 가능!
yejiInfo.name = "yeji yun"		// 변경 가능!
~~~
만약 구조체를 상수 let으로 선언하면 인스턴스 내부의 프로퍼티 값을 변경할 수 없다.

### 클래스
~~~swift
class 클래스 이름 {
	프로퍼티와 메서드들
}
~~~
클래스를 정의하는 방법은 구조체와 흡사하지만 클래스는 상속을 받을 수 있기 때문에 상속을 받을 때는 클래스 이름 뒤에 콜론(:)을 써주고 부모 클래스 이름을 명시함.
~~~swift
class 클래스 이름: 부모클래스 이름 {
	프로퍼티와 메서드들
}
~~~
* 사람의 기본정보를 프로퍼티로 갖는 클래스를 정의  
~~~swift
class Person {
	var height: Float = 0.0
	var weight: Float = 0.0
}
~~~
* 클래스 인스턴스의 생성과 초기화
클래스를 정의한 후, 인스턴스를 생성하고 초기화하고자 할 때는 기본적인 이니셜라이저를 사용한다.
위에서 정의한 Person 클래스에서는 프로퍼티의 기본값이 지정되어 있으므로 전달 인자를 통하여 따로 초깃값을 전달해주지 않아도 된다.  
구조체와 다르게 클래스의 인스턴스는 참조 타입이므로 클래스의 인스턴스를 상수 let으로 선언해도 내부 프로퍼티 값을 변경할 수 있다.
~~~swift
let yagom: Person = Person()
yagom.height = 123.4
yagom.weight = 123.4
~~~
* 클래스 인스턴스의 소멸
클래스 인스턴스는 참조 타입이므로 더는 참조할 필요가 없을 때 메모리에서 해제된다. 소멸되기 직전 deinit라는 메서드가 호출되는데, 클래스 내부에 deinit 메서드를 구현해주면 소멸되기 직전 deinit 메서드가 호출된다. 이렇게 호출되는 deinit 메서드를 **디이니셜라이저** 라고 부른다.


### 구조체 vs 클래스
* 구조체는 상속할 수 없다.
* 타입캐스팅은 클래스의 인스턴스에만 허용된다.
* 디이니셜라이저는 클래스의 인스턴스에만 활용할 수 있다.
* 참조 횟수 계산은 클래스의 인스턴스에만 적용된다.

구조체와 클래스는 정의 방법, 인스턴스화 방법 등을 비롯한 많은 부분에서 비슷해보이지만 두 타입을 구분 짓는 가장 큰 차이점은 구조체는 값 타입, 클래스는 참조 타입이라는 것이다.

* **값 타입과 참조 타입**
값 타입과 참조 타입의 가장 큰 차이는 '무엇이 전달되느냐'이다. 예를 들어 어떤 함수의 전달 인자로 값 타입의 값을 넘긴다면 **전달될 값이 복사**되어 전달된다. (call by value) 반면, 참조 타입이 전달 인자로 전달될 때는 값을 복사하지 않고 참조가 전달된다. (call by reference)
* 스위프트의 기본 데이터 타입은 모두 구조체이다

### 구조체와 클래스 어떤 것을 선택해야 하는가?
프로젝트의 성격에 따라, 데이터의 활용도에 따라, 특정 타입을 구현할 때 구조체와 클래스 둘 중 하나를 선택해서 사용해야 한다.  
애플은 가이드라인에서 다음 조건 중 하나 이상에 해당하면 구조체를 사용하는 것을 권장한다.
* 연관된 간단한 값의 집합을 캡슐화하는 것만이 목적일 때
* 캡슐화한 값을 참조하는 것보다 복사하는 것이 합당할 때
* 구조체에 저장된 프로퍼티가 값 타입이며 참조하는 것보다 복사하는 것이 합당할 때
* 다른 타입으로부터 상속받거나 자신을 상속할 필요가 없을 때


> 지금 블로그 가독성 진짜 마음에 안든다... 조만간 옮기거나 손봐야겠다
