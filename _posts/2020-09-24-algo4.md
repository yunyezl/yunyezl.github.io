---
title:  "[algorithm] 게임 개발"
excerpt: "이것이 코딩테스트다 with python"

categories:
  - algorithm
tags:
  - algorithm
  - codingtest
  - study
  - python
last_modified_at: 2020-09-24T05:48:00-05:00
---

# 게임개발
현민이는 게임 캐릭터가 맵 안에서 움직이는 시스템을 개발 중이다. 캐릭터가 있는 장소는 1 x 1 크기의 정사각형으로 이뤄진 N-X M 크기의 직사각형으로, 각각의 칸은 육지 또는 바다이다 캐릭터는 동서남북 중 한 곳을 바라본다.
맵의 각 칸은 (A,B)로 나타낼 수 있고, A는 북쪽으로부터 떨어진 칸의 개수, B는 서쪽으로부터 떨어진 칸의 개수이다. 캐릭터는 상하좌우로 움직일 수 있고, 바다로 되어 있는 공간에는 갈 수 없다. 캐릭터의 움직임을 설정하기 위해 정해 놓은 메뉴얼은 이러하다.
1. 현재 위치에서 현재 방향을 기준으로 왼쪽 방향부터 차례대로 갈 곳을 정한다.
2. 캐릭터의 바로 왼쪽 방향에 아직 가보지 않은 칸이 존재한다면, 왼쪽 방향으로 회전한 다음 왼쪽으로 한 칸을 전진한다. 왼쪽 방햐에 가보지 않은 칸이 없다면, 왼쪽 방향으로 회전만 수행하고 1단계로 돌아간다.
3. 만약 네 방향 모두 이미 가본 칸이거나 바다로 되어 있는 칸인 경우에는, 바라보는 방향을 유지한 채로 한 칸 뒤로 가고 1단계로 돌아간다. 단, 이때 뒤쪽 방향이 바다인 칸이라 뒤로 갈 수 없다면 움직임을 중단한다.

##### 입력조건
* 첫째 줄에 맵의 세로 크기 n과 가로 크기 m을 공백으로 구분하여 입력
* 둘째 줄에 게임 캐릭터가 있는 칸의 좌표와 바라보는 방향 d가 서로 각각 공백으로 주어짐. 0은 북쪽, 1은 동쪽, 2는 남쪽, 3은 서쪽
* 셋째 줄부터 맵이 육지인지 바다인지에 대한 정보. N개의 줄에 맵의 상태가 북쪽부터 남쪽 순서대로, 각 줄의 데이터는 서쪽부터 동쪽 순서대로 주어진다. 맵의 외곽은 항상 바다로 되어있다. 0은 육지, 1은 바다
* 처음에 캐릭터가 위치한 칸의 상태는 항상 육지

~~~python
n, m = map(int, input().split()) # 게임맵의 크기 지정
visited = [[0] * m for _ in range(n)] # 방문한 적이 있는지 없는지를 카운트하기 위해 게임맵의 크기만큼 0으로 초기화
k, j, d = map(int, input().split()) # 캐릭터의 위치와 캐릭터가 바라보고 있는 방향
gameMap = [[int(n) for n in input().split()] for m in range(m)]
count = 1
turn_count = 0
visited[k][j] = 1 # 처음 캐릭터가 있는 곳 방문 체크

def left(d):
    d -= 1
    if d == -1:
        d = 3
    return d

#(-1,0) (0,1) (1,0) (0,-1) 캐릭터의 기본 위치에서 괄호안의 각 숫자를 더하면 순서대로 북/동/남/서 로 이동함 (왼쪽으로 이동)
x = [-1, 0, 1, 0]
y = [0, 1, 0, -1]

while True:
    d = left(d) # 무조건 한번 돌림
    px = k + x[d]
    py = j + y[d]
    if gameMap[px][py] == 0 and visited[px][py] == 0: # 돌린 방향으로 이동했을때 0이고, 한번도 방문한 적이 없다면
        visited[px][py] = 1 # 중복 카운트 방지
        k = px
        j = py # 실제로 이동시킴
        count += 1
        turn_count = 0
        continue
    else:
        turn_count += 1
    if turn_count == 4: # 네 번 돌았는데 아무데도 가지 못함 (4면이 바다로 둘러쌓임)
        px = k - x[d]
        py = j - y[d] #후진
        if gameMap[px][py] == 0: #뒤로 갈 수 있다면(방문했어도 후진은 가능. 카운트 안하면 됨.)
            k = px
            j = py
        else: #후진 불가(뒷면이 바다)
            break)
        turn_count = 0 #뒤로 가기 성공한 경우 새로운 좌표의 turn_count

print(count)
~~~


왼쪽으로 돌릴때 -1을 해야 하는 이유는 북쪽을 바라 보고 있을 때 왼쪽으로 돌리면 서쪽을 보게 되고, 이 때 서쪽으로 가기 위한 좌표 값(0, -1)을 사용해야 하므로 첫 위치 0에서 3으로 가야한다. offset에 -1은 없기 때문에 -1가 될 경우 3으로 바꿔서, x[3]y[3] 즉 0, -1을 현재 캐릭터가 위치하고 있는 좌표값에 더하여 서쪽으로 이동시킬 수 있도록 한다.  
즉 입력 조건에서 각 방향을 의미하는 숫자를 배열의 offset으로 사용하여 해당 offset에는 그 좌표로 가기 위해 더해야하는 만큼의 값으로 배열을 구성한다.
visited 배열을 따로 만들어서 방문 횟수를 체크해야 하는 이유는 이미 방문한 적 있는 육지를 중복으로 카운트하는 것을 방지하기 위함이다.  

##### * 초기 위치의 visited[k][j]를 1로 초기화하지 않는다면?

* 초기 위치의 방문을 체크하지 않음
![image](https://user-images.githubusercontent.com/69361613/94107607-ce5db600-fe78-11ea-9171-0fd608b0d357.png)
* 초기 위치의 방문을 체크함
![image](https://user-images.githubusercontent.com/69361613/94107697-f5b48300-fe78-11ea-84da-6c6cc319e6b1.png)

의도대로라면 아래쪽으로 쭉 가서 7이라는 결과값이 나와야하는데, 초기 위치를 체크하지 않으면 2, 1에서 남쪽을 볼때 왼쪽으로 두 번 돌렸을 때 조건에 걸리게 돼서 뒤로 가게 됨.
정면으로 가는 것이 아니라 왼쪽으로 한번 돌려서 가는 것임을 유의해야함.

**기억하기**  
nxm 좌표값을 0으로 초기화 -> visited = [[0] * m for _ in range(n)]

