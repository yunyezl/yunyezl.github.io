---
title:  "[algorithm] 정렬 이론"
excerpt: "이것이 코딩테스트다 with python"

categories:
  - algorithm
tags:
  - algorithm
  - codingtest
  - study
  - python
  - sort
last_modified_at: 2020-10-08T10:54:00-05:00
---

## 선택 정렬
데이터가 무작위로 여러 개 있을 때, 이 중에서 가장 작은 데이터를 선택해 맨 앞에 있는 데이터와 바꾸고, 그다음 작은 데이터를 선택해 앞에서 두 번째 데이터와 바꾸는 과정을 반복한다. 가장 작은 것을 선택해서 앞으로 보내는 과정을 반복해서 수행하다 보면, 전체 데이터의 정렬이 이루어진다.

~~~ python
array = [7, 5, 9, 0, 3, 1, 6, 2 ,4, 8]

for i in range(len(array)):
    min_index = i # 가장 작은 원소의 인덱스
    for j in range(i+1, len(array)):
        if array[min_index] > array[j]:
            min_index = j
        array[i], array[min_index] = array[min_index], array[i] #스와프
~~~

#### *파이썬의 SWAP*
C++, JAVA와 같은 언어에 익숙한 사람이라면 값을 swap할때 temp라는 임시 변수에 값을 저장하고 값을 교환하는 방식에 익숙할 것이다. 그러나 파이썬은 위의 코드와 같이 간단히 두 원소의 위치를 변경할 수 있다.


## 삽입 정렬
선택 정렬은 시간 복잡도 측면에서 매우 비효율적이다. 삽입 정렬은 특정한 데이터를 적절한 위치에 '삽입'한다는 의미에서 삽입 정렬이라고 부른다. 현재 데이터의 상태와 상관없이 무조건 모든 원소를 비교하고 위치를 바꾸는 선택정렬과 달리 삽입정렬은 그렇지 않다. 삽입 정렬은 특정한 데이터가 적절한 위치에 들어가기 이전에, 그 앞까지의 데이터는 이미 정렬되어 있다고 가정한다. 정렬되어 있는 데이터 리스트에서 적절한 위치를 찾은 뒤, 그 위치에 삽입된다는 점이 특징이다. 삽입 정렬은 배열이 '거의' 되어있는 상태에서 매우 효율적이다.  
삽입정렬은 index 1부터 이전의 index들과 값을 비교하고, 자신보다 작은 인덱스를 만날 경우 스왑을 중단하고 해당 인덱스의 앞에 위치한다. (오름차순 기준) 앞의 index들은 이미 정렬되어있는 상태이기 때문이다.

~~~ python
array = [7, 5, 9, 0, 3, 1, 6, 2 ,4, 8]

for i in ragne(1, len(array)):
    for j in range(i, 0, -1):
        if array[j] < array[j-1]:
            array[j], array[j - 1] = array[j - 1], array[j]
        else:
            break
~~~

## 퀵 정렬
퀵 정렬은 기준을 설정한 다음 큰 수와 작은 수를 교환한 후 리스트를 반으로 나누는 방식으로 동작한다. 퀵 정렬에서는 피벗Pivot이 사용된다. 큰 숫자와 작은 숫자를 교환할 때, 교환하기 위한 기준을 바로 피벗이라고 한다. 퀵 정렬을 수행하기 전에는 피벗을 어떻게 설정할 것인지 미리 명시해야 한다. 피벗을 설정하고 리스트를 분할하는 방법에 따라서 여러 가지 방식으로 퀵 정렬이 구분되는데, 여기서는 호어 분할만 다룬다.
#### 호어분할 방식
* 리스트에서 첫 번째 데이터를 피벗으로 정한다.  

이와 같은 방식으로 피벗을 설정한 뒤 *왼쪽에서부터 피벗보다 큰 데이터를 찾고, 오른쪽에서부터 피벗보다 작은 데이터*를 찾는다. 그 다음 큰 데이터와 작은 데이터의 위치를 서로 교환해준다. 데이터가 엇갈릴 경우 작은 데이터와 피벗을 교환한다.

~~~python
array = [5, 7, 9, 0 , 3, 1, 6, 2, 4, 8]

def quick_sort(array, start, end):
    if start >= end:
        return
    pivot = start
    left = start + 1
    right = end
    while left <= right:
        while left <= end and array[left] <= array[pivot]:
            left += 1
        while right > start and array[right] >= array[pivot]:
            right -= 1
        if left > right:
            array[right], array[pivot] = array[pivot] = array[right]
        else:
            array[left], array[right] = array[right], array[left]
    quick_sort(array, start, right-1)
    quick_sort(array, right+1, end)
~~~

## 계수 정렬
계수 정렬 알고리즘은 특정한 조건이 부합할 때만 사용할 수 있지만 매우 빠른 정렬 알고리즘이다. 모든 데이터가 양의 정수인 상황을 가정해보자. 데이터의 개수가 N, 데이터 중 최댓값이 K일 때, 계수 정렬은 최악의 경우에도 수행 시간 O(N+K)를 보장한다. 계수 정렬은 이처럼 매우 빠르게 동작할 뿐만 아니라 원리 또한 매우 간단하다. 다만, 계수 정렬은 '데이터의 크기 범위가 제한되어 정수 형태로 표현할 수 있을 때'만 사용할 수 있다. 일반적으로 가장 큰 데이터와 작은 데이터의 차이가 1,000,000을 넘지 않을 때 효과적으로 사용할 수 있다. 계수 정렬을 이용할 때는 '모든 범위를 담을 수 있는 크기의 리스트(배열)'을 선언해야 하기 때문이다.  
계수 정렬은 앞선 정렬들과 달리 비교 기반 정렬 알고리즘이 아니다. 일반적으로 별도의 리스트를 선언하고 그 안에 정렬에 대한 정보를 담는다는 특징이 있다.  


예를 들어 비교할 데이터가 총 10개가 있다고 하면, 우리는 크기가 10인 모든 데이터가 0으로 초기화되어있는 별도의 리스트를 선언할 수 있다. 이후 해당 리스트(0으로 초기화 되어있는 리스트)와 실제 데이터가 담겨있는 리스트를 하나씩 비교하여, 실제 데이터값과 동일한 인덱스의 데이터를 1씩 증가시키면(0으로 초기화되어있는 리스트에서) 계수 정렬이 된다.  
결과적으로 0으로 초기화시킨 리스트는 배열의 데이터가 각각 몇 번 등장했는지 횟수가 기록된다. 그리고 값을 저장하고 있는만큼 인덱스를 그대로 출력하면 그 자체로 정렬이 된다. 0번 인덱스에 2가 저장되어있다면, 0을 두번 출력하고, 다음으로 1번 인덱스에 3이 저장되어 있다면 0 0 1 1 1 이 출력되고, 이 과정을 마지막까지 반복하면 정렬된 데이터가 출력된다.

~~~python
array[7, 5, 9, 0, 3, 1, 6, 2, 9, 1, 4, 8, 0, 5, 2]
count = [0] * (max(array) + 1)

for i in range(len(array)):
    count[array[i]] += 1

for i in range(len(count)):
    for j in range(count[i]):
        print(i, end=' ')
~~~



